#!/usr/bin/env python3

#   Copyright 2025 Ewogijk
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.

import json
from pathlib import Path

from SCons.Environment import *
from SCons.Variables import *

######################################################################################################
#                                   Target Compiler Config                                           #
######################################################################################################

# Define command line arguments
cli_vars = Variables(None, ARGUMENTS)
cli_vars.Add(
    EnumVariable(
        'build',
        'The build type determines if compiler optimizations are used, release builds are optimized.',
        'dev',
        allowed_values=['dev', 'release']
    )
)
cli_vars.Add(
    EnumVariable(
        'arch',
        'The CPU architecture the kernel will be build on.',
        'x86_64',
        allowed_values=['x86_64']
    )
)
cli_vars.Add(
    (
        'compiler',
        'The absolute path to the gcc compiler.',
        ''
    )
)
cli_vars.Add(
    (
        'kernel_elf_name',
        'Name of the generated kernel elf.',
        'runeKernel.elf'
    )
)
cli_vars.Add(
    (
        'kernel_version',
        'The version of this kernel build.',
        '0.0.0-dummy'
    )
)
cli_vars.Add(
    (
        'os_location',
        'The absolute path to the OS build on the target machines filesystem.',
        ''
    )
)
cli_vars.Add(
    BoolVariable(
        'qemu_build',
        'Enables additional qemu specific debugging features in the kernel.',
        True
    )
)
cli_vars.Add(
    (
        'rune_partition_type_guid',
        'The partition type GUID of all GPT partitions generated by the rune Kernel or RuneToolkit. During boot the'
        'kernel expects the Data partition to have this GUID.',
        ''
    )
)
cli_vars.Add(
    (
        'kernel_partition_unique_guid',
        'The partition unique ID of the EFI System Partition, the Kernel ELF must be installed here and it expects to'
        'find a partition with this GUID during boot.',
        ''
    )
)
cli_vars.Add(
    (
        'os_partition_unique_guid',
        'The partition unique ID of the data partition, the OS ELF must be installed here and the kernel expects to'
        'find a partition with this GUID during boot.',
        ''
    )
)


target_env = Environment(
    variables=cli_vars,
    AS='nasm',
)
Help(cli_vars.GenerateHelpText(target_env))
arch = target_env['arch']
build = target_env['build']

compiler = Path(target_env['compiler'])
target_env['CXX'] = str(compiler / 'bin' / 'x86_64-elf-g++')
target_env['CPPPATH'] = str(compiler / 'bin' / 'x86_64-elf-g++')

# Include directories
target_env['CPPPATH'] = [
    str(Path.cwd() / 'Include'),
    str(Path.cwd() / '..' / 'Hammer' / 'Include'),
]

# Compiler flags
target_env['CXXFLAGS'] = [
    '-Wall',
    '-Wextra',
    '-ffreestanding',
    '-fno-exceptions',
    '-fno-rtti',
    '-fstack-protector-all',
    '-m64',
    '-mcmodel=kernel',
    '-mno-mmx',
    '-mno-red-zone',
    '-fno-use-cxa-atexit',  # Do not call destructors for global objects
    '-g',
]

# Linker flags
target_env['LINKFLAGS'] = [
    '-ffreestanding',
    '-lgcc',
    '-nostdlib',
    '-static',
    '-pie',
    '-z', 'text',
    '-z', 'max-page-size=0x1000',
    '-g',
]

# Nasm flags
target_env['ASFLAGS'] = [
    '-Wall',
    '-f', 'elf64',
    '-I', str(Path.cwd() / 'Src' / 'Arch' / arch)
]

if build == 'release':
    # enable optimizations
    target_env['CXXFLAGS'].append('-O2')
    target_env['LINKFLAGS'].append('-O2')

# Change scons messages for better readability
target_env.Replace(
    ASCOMSTR='Assembling [$SOURCE]',
    CXXCOMSTR='Compiling [$SOURCE]',
    ARCOMSTR='Creating static library [$TARGET]',
    RANLIBCOMSTR='Updating static library [$TARGET]',
    LINKCOMSTR='Linking [$TARGET]',
    INSTALLSTR='Installing [$TARGET]'
)
Export('target_env')


######################################################################################################
#                                           Code Generation                                          #
######################################################################################################


def create_macro_def_json(out_file: str):
    parts = target_env['kernel_version'].split('-')
    kernel_prerelease = parts[1] if len(parts) > 1 else ''
    parts = parts[0].split('.')
    kernel_major = parts[0] if len(parts) > 0 else 0
    kernel_minor = parts[1] if len(parts) > 1 else 0
    kernel_patch = parts[2] if len(parts) > 2 else 0
    macro_defs = [
        ['Architecture the kernel was build for.', f'ARCH {arch}'],
        ['The kernel major version', f'K_MAJOR {kernel_major}'],
        ['The kernel minor version', f'K_MINOR {kernel_minor}'],
        ['The kernel patch version', f'K_PATCH {kernel_patch}'],
        ['The kernel patch version', f'K_PRERELEASE "{kernel_prerelease}"'],
        ['The absolute path to the OS executable', f'OS "{target_env["os_location"]}"'],
        [
            'Partition type GUID to be used by all GPT partition generated by the kernel.',
            f'RUNE_PARTITION_TYPE_GUID "{target_env["rune_partition_type_guid"]}"'
        ],
        [
            'Partition unique ID of the Kernel/EFI System Partition.',
            f'KERNEL_PARTITION_UNIQUE_GUID "{target_env["kernel_partition_unique_guid"]}"'
        ],
        [
            'Partition unique ID of the OS partition.',
            f'OS_PARTITION_UNIQUE_GUID "{target_env["os_partition_unique_guid"]}"'
            f''],
    ]
    if '64' in arch:
        macro_defs.append(['Activate 64-bit related features in the entry e.g. 64-bit memory addresses', 'IS_64_BIT'])
    if target_env['qemu_build']:
        macro_defs.append(['Determines serial logging behavior.', 'IS_QEMU_HOST'])
    with open(out_file, 'w') as f:
        json.dump(macro_defs, f, indent=4)


# Only run code generation if the kernel should be build
if not GetOption('clean'):
    # Provide the python scripts as source so the code gen is always triggered when the scripts are updated
    #                           OR
    # Obviously the generated source file is missing
    target_env.Command(
        f'Src/Arch/{arch}/CPU/Interrupt/ISR_Stubs.inc',
        'BuildTools/GenerateISRStubsAssembly.py',
        'python3 $SOURCE $TARGET'
    )
    target_env.Command(
        f'Src/Arch/{arch}/CPU/Interrupt/ISR_Stubs.h',
        'BuildTools/GenerateISRStubsCPP.py',
        'python3 $SOURCE $TARGET'
    )
    target_env.Command(
        'Include/LibK/Lat15-Terminus16.h',
        'BuildTools/PSF2ToCPP.py',
        'python3 $SOURCE $TARGET BuildTools/Lat15-Terminus16.psf'
    )
    # Dunno how to make this only run when cli args change -> just run it everytime
    create_macro_def_json('BuildTools/MacroDefs.json')
    target_env.Command(
        'Include/LibK/Build.h',
        ['BuildTools/GenerateBuildHeader.py', 'BuildTools/MacroDefs.json'],
        'python3 $SOURCE $TARGET BuildTools/MacroDefs.json'
    )

######################################################################################################
#                                           Kernel build                                             #
######################################################################################################


build_dir = Path('Build') / f'{arch}-{build}'
target_env.SConscript(
    str(Path('..') / 'Hammer' / 'Src' / 'SConscript'),
    variant_dir=str(build_dir / 'Hammer'),
    duplicate=0
)
target_env.SConscript(
    str(Path('Src') / 'App' / 'SConscript'),
    variant_dir=str(build_dir / 'App'),
    duplicate=0
)
target_env.SConscript(
    str(Path('Src') / 'Boot' / 'SConscript'),
    variant_dir=str(build_dir / 'Boot'),
    duplicate=0
)
target_env.SConscript(
    str(Path('Src') / 'BuiltInPlugin' / 'SConscript'),
    variant_dir=str(build_dir / 'BuiltInPlugin'),
    duplicate=0
)
target_env.SConscript(
    str(Path('Src') / 'CPU' / 'SConscript'),
    variant_dir=str(build_dir / 'CPU'),
    duplicate=0
)
target_env.SConscript(
    str(Path('Src') / 'Device' / 'SConscript'),
    variant_dir=str(build_dir / 'Device'),
    duplicate=0
)
target_env.SConscript(
    str(Path('Src') / 'LibK' / 'SConscript'),
    variant_dir=str(build_dir / 'LibK'),
    duplicate=0
)
target_env.SConscript(
    str(Path('Src') / 'Memory' / 'SConscript'),
    variant_dir=str(build_dir / 'Memory'),
    duplicate=0
)
target_env.SConscript(
    str(Path('Src') / 'Arch' / arch / 'SConscript'),
    variant_dir=str(build_dir / 'Arch'),
    duplicate=0
)
target_env.SConscript(
    str(Path('Src') / 'SystemCall' / 'SConscript'),
    variant_dir=str(build_dir / 'SystemCall'),
    duplicate=0
)
target_env.SConscript(
    str(Path('Src') / 'VirtualFileSystem' / 'SConscript'),
    variant_dir=str(build_dir / 'VirtualFileSystem'),
    duplicate=0
)

Import('Hammer')
Import('App')
Import('Boot')
Import('BuiltInPlugin')
Import('CPU')
Import('Device')
Import('LibK')
Import('Memory')
Import('Arch')
Import('SystemCall')
Import('VirtualFileSystem')
Import('crti')
Import('crtn')
objects = [
    crti,
    compiler / 'lib' / 'gcc' / 'x86_64-elf' / '13.2.0' / 'crtbegin.o',
    Boot,
    BuiltInPlugin,
    SystemCall,
    App,
    VirtualFileSystem,
    Device,
    CPU,
    Memory,
    Arch,
    LibK,
    Hammer,
    compiler / 'lib' / 'gcc' / 'x86_64-elf' / '13.2.0' / 'crtend.o',
    crtn
]

target_env.Append(
    LINKFLAGS=['-T', target_env.File('Kernel.ld').srcnode().path]
)

target_env.Program(build_dir / target_env['kernel_elf_name'], objects)
