#!/usr/bin/env python3

#   Copyright 2025 Ewogijk
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.

import json
from pathlib import Path

from SCons.Environment import *
from SCons.Variables import *

######################################################################################################
#                                   Target Compiler Config                                           #
######################################################################################################

# Define command line arguments
vars = Variables('BuildVariables.py')
vars.Add(
    EnumVariable(
        'build',
        'The build type determines if compiler optimizations are used, release builds are optimized.',
        'dev',
        allowed_values=['dev', 'release']
    )
)
vars.Add(
    EnumVariable(
        'arch',
        'The CPU architecture the kernel will be build on.',
        'x86_64',
        allowed_values=['x86_64']
    )
)
vars.Add(
    (
        'version',
        'The version of this kernel build.',
        '0.0.0-dummy'
    )
)
vars.Add(
    (
        'os_executable',
        'The absolute path to the OS build on the target machines filesystem.',
        ''
    )
)
vars.Add(
    BoolVariable(
        'qemu_build',
        'Enables additional qemu specific debugging features in the kernel.',
        True
    )
)
vars.Add(
    (
        'gcc',
        'The path to the gcc executable of the kernel cross compiler..',
        ''
    )
)
vars.Add(
    (
        'gpp',
        'The path to the g++ executable of the kernel cross compiler..',
        ''
    )
)
vars.Add(
    (
        'crtbegin',
        'The path to the crtbegin.o file of the kernel cross compiler.',
        ''
    )
)
vars.Add(
    (
        'crtend',
        'The path to the crtend.o file of the kernel cross compiler.',
        ''
    )
)



target_env = Environment(
    variables=vars,
    AS='nasm',
)
Help(vars.GenerateHelpText(target_env))
arch = target_env['arch']
build = target_env['build']

target_env['CXX'] = target_env['gpp']
target_env['CPPPATH'] = target_env['gpp']

# Include directoriesx
target_env['CPPPATH'] = [
    str(Path.cwd() / 'Include'),
]

# Compiler flags
target_env['CXXFLAGS'] = [
    '-Wall',
    '-Wextra',
    '-ffreestanding',
    '-fno-exceptions',
    '-fno-rtti',
    '-fstack-protector-all',
    '-m64',
    '-mcmodel=kernel',
    '-mno-mmx',
    '-mno-red-zone',
    '-fno-use-cxa-atexit',  # Do not call destructors for global objects
    '-g',
]

# Linker flags
target_env['LINKFLAGS'] = [
    '-ffreestanding',
    '-lgcc',
    '-nostdlib',
    '-static',
    '-pie',
    '-z', 'text',
    '-z', 'max-page-size=0x1000',
    '-g',
]

# Nasm flags
target_env['ASFLAGS'] = [
    '-Wall',
    '-f', 'elf64',
    '-I', str(Path.cwd() / 'Src' / 'Arch' / arch)
]

if build == 'release':
    # enable optimizations
    target_env['CXXFLAGS'].append('-O2')
    target_env['LINKFLAGS'].append('-O2')

# Change scons messages for better readability
target_env.Replace(
    ASCOMSTR='Assembling [$SOURCE]',
    CXXCOMSTR='Compiling [$SOURCE]',
    ARCOMSTR='Creating static library [$TARGET]',
    RANLIBCOMSTR='Updating static library [$TARGET]',
    LINKCOMSTR='Linking [$TARGET]',
    INSTALLSTR='Installing [$TARGET]'
)
Export('target_env')


######################################################################################################
#                                           Code Generation                                          #
######################################################################################################


def create_macro_def_json(out_file: str):
    parts = target_env['version'].split('-')
    kernel_prerelease = parts[1] if len(parts) > 1 else ''
    parts = parts[0].split('.')
    kernel_major = parts[0] if len(parts) > 0 else 0
    kernel_minor = parts[1] if len(parts) > 1 else 0
    kernel_patch = parts[2] if len(parts) > 2 else 0
    macro_defs = [
        ['Architecture the kernel was build for.', f'ARCH {arch}'],
        ['The kernel major version', f'MAJOR {kernel_major}'],
        ['The kernel minor version', f'MINOR {kernel_minor}'],
        ['The kernel patch version', f'PATCH {kernel_patch}'],
        ['The kernel patch version', f'PRERELEASE "{kernel_prerelease}"'],
        ['The absolute path to the OS executable', f'OS "{target_env["os_executable"]}"'],
    ]
    if '64' in arch:
        macro_defs.append(['Activate 64-bit related features in the entry e.g. 64-bit memory addresses', 'BIT64'])
    if target_env['qemu_build']:
        macro_defs.append(['Determines serial logging behavior.', 'QEMU_HOST'])
    with open(out_file, 'w') as f:
        json.dump(macro_defs, f, indent=4)


# Only run code generation if the kernel should be build
if not GetOption('clean'):
    # Provide the python scripts as source so the code gen is always triggered when the scripts are updated
    #                           OR
    # Obviously the generated source file is missing
    print("CODE GEN STUFF")
    target_env.Command(
        f'Src/Arch/{arch}/CPU/Interrupt/ISR_Stubs.inc',
        'BuildTools/GenerateISRStubsAssembly.py',
        'python3 $SOURCE $TARGET'
    )
    target_env.Command(
        f'Src/Arch/{arch}/CPU/Interrupt/ISR_Stubs.h',
        'BuildTools/GenerateISRStubsCPP.py',
        'python3 $SOURCE $TARGET'
    )
    target_env.Command(
        'Include/KernelRuntime/Lat15-Terminus16.h',
        'BuildTools/PSF2ToCPP.py',
        'python3 $SOURCE $TARGET BuildTools/Lat15-Terminus16.psf'
    )
    # Dunno how to make this only run when cli args change -> just run it everytime
    create_macro_def_json('BuildTools/MacroDefs.json')
    target_env.Command(
        'Include/KernelRuntime/Build.h',
        ['BuildTools/GenerateBuildHeader.py', 'BuildTools/MacroDefs.json'],
        'python3 $SOURCE $TARGET BuildTools/MacroDefs.json'
    )

######################################################################################################
#                                           Kernel build                                             #
######################################################################################################


build_dir = Path('Build') / f'{arch}-{build}'
target_env.SConscript(
    str(Path('Src') / 'Ember' / 'SConscript'),
    variant_dir=str(build_dir / 'Ember'),
    duplicate=0
)
target_env.SConscript(
    str(Path('Src') / 'KernelRuntime' / 'SConscript'),
    variant_dir=str(build_dir / 'KernelRuntime'),
    duplicate=0
)
target_env.SConscript(
    str(Path('Src') / 'Arch' / arch / 'SConscript'),
    variant_dir=str(build_dir / 'Arch'),
    duplicate=0
)
target_env.SConscript(
    str(Path('Src') / 'Memory' / 'SConscript'),
    variant_dir=str(build_dir / 'Memory'),
    duplicate=0
)
target_env.SConscript(
    str(Path('Src') / 'CPU' / 'SConscript'),
    variant_dir=str(build_dir / 'CPU'),
    duplicate=0
)
target_env.SConscript(
    str(Path('Src') / 'Device' / 'SConscript'),
    variant_dir=str(build_dir / 'Device'),
    duplicate=0
)
target_env.SConscript(
    str(Path('Src') / 'VirtualFileSystem' / 'SConscript'),
    variant_dir=str(build_dir / 'VirtualFileSystem'),
    duplicate=0
)
target_env.SConscript(
    str(Path('Src') / 'App' / 'SConscript'),
    variant_dir=str(build_dir / 'App'),
    duplicate=0
)
target_env.SConscript(
    str(Path('Src') / 'SystemCall' / 'SConscript'),
    variant_dir=str(build_dir / 'SystemCall'),
    duplicate=0
)
target_env.SConscript(
    str(Path('Src') / 'Boot' / 'SConscript'),
    variant_dir=str(build_dir / 'Boot'),
    duplicate=0
)
target_env.SConscript(
    str(Path('Src') / 'BuiltInPlugin' / 'SConscript'),
    variant_dir=str(build_dir / 'BuiltInPlugin'),
    duplicate=0
)

Import('Ember')
Import('KernelRuntime')
Import('Arch')
Import('Memory')
Import('CPU')
Import('Device')
Import('VirtualFileSystem')
Import('App')
Import('SystemCall')
Import('BuiltInPlugin')
Import('Boot')
Import('crti')
Import('crtn')
objects = [
    crti,
    target_env['crtbegin'],
    Boot,
    BuiltInPlugin,
    SystemCall,
    App,
    VirtualFileSystem,
    Device,
    CPU,
    Memory,
    Arch,
    KernelRuntime,
    Ember,
    target_env['crtend'],
    crtn
]

target_env.Append(
    LINKFLAGS=['-T', target_env.File('Kernel.ld').srcnode().path]
)

target_env.Program(build_dir / 'runeKernel.elf', objects)
