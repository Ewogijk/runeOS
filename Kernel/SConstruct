#!/usr/bin/env python3

#   Copyright 2025 Ewogijk
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.

import json
from pathlib import Path

from SCons.Environment import *
from SCons.Variables import *

######################################################################################################
#                                   Target Compiler Config                                           #
######################################################################################################

# Define command line arguments
vars = Variables("BuildVariables.py")
vars.Add(
    EnumVariable(
        "build",
        "The build type determines if compiler optimizations are used, release builds have compiler optimizations.",
        "debug",
        allowed_values=["release", "debug", "test", "ci"],
    )
)
vars.Add(
    EnumVariable(
        "arch",
        "The CPU architecture the kernel will be build for.",
        "x86_64",
        allowed_values=["x86_64"],
    )
)
vars.Add(
    BoolVariable(
        "qemu_build",
        "Enables additional qemu specific debugging features in the kernel.",
        True,
    )
)
vars.Add(
    (
        "system_loader",
        "Absolute path to the system loader executable.",
        "",
    )
)
vars.Add(
    (
        "c",
        "The absolute path to the c cross compiler e.g. x86_64-elf-gcc.",
        "/path/to/your/cross-compiler/bin/x86_64-elf-gcc",
    )
)
vars.Add(
    (
        "cpp",
        "The absolute path to the cpp cross compiler e.g. x86_64-elf-g++.",
        "/path/to/your/cross-compiler/bin/x86_64-elf-g++",
    )
)
vars.Add(
    (
        "crt_begin",
        "The absolute path to the crtbegin.o file of the cross compiler.",
        "/path/to/your/cross-compiler/lib/gcc/x86_64-elf/<version>/crtbegin.o",
    )
)
vars.Add(
    (
        "crt_end",
        "The absolute path to the crtend.o file of the cross compiler.",
        "/path/to/your/cross-compiler/lib/gcc/x86_64-elf/<version>/crtend.o",
    )
)


target_env = Environment(
    tools=['default', 'compilation_db'],
    variables=vars,
    AS="nasm",
)
Help(vars.GenerateHelpText(target_env))
arch = target_env["arch"]
build = target_env["build"]

target_env["CXX"] = target_env["cpp"]
target_env["CPPPATH"] = target_env["cpp"]

# Include directoriesx
target_env["CPPPATH"] = [
    str(Path.cwd() / "Include"),
]

# Compiler flags
target_env["CXXFLAGS"] = [
    "-std=c++23",
    "-Wall",
    "-Wextra",
    "-ffreestanding",
    "-fno-exceptions",
    "-fno-rtti",
    "-fstack-protector-all",
    "-fno-threadsafe-statics",
    "-m64",
    "-mcmodel=kernel",
    "-mno-mmx",
    "-mno-red-zone",
    "-fno-use-cxa-atexit",  # Do not call destructors for global objects
    "-g",
    "-mincoming-stack-boundary=3",
]

# Linker flags
target_env["LINKFLAGS"] = [
    "-ffreestanding",
    "-lgcc",
    "-nostdlib",
    "-static",
    "-pie",
    "-z",
    "text",
    "-z",
    "max-page-size=0x1000",
    "-g",
]

# Nasm flags
target_env["ASFLAGS"] = [
    "-Wall",
    "-f",
    "elf64",
    "-I",
    str(Path.cwd() / "Src" / "Arch" / arch),
]

if build == "release":
    # enable optimizations
    target_env["CXXFLAGS"].append("-O2")
    target_env["LINKFLAGS"].append("-O2")

# Change scons messages for better readability
target_env.Replace(
    ASCOMSTR="Assembling [$SOURCE]",
    CXXCOMSTR="Compiling [$SOURCE]",
    ARCOMSTR="Creating static library [$TARGET]",
    RANLIBCOMSTR="Updating static library [$TARGET]",
    LINKCOMSTR="Linking [$TARGET]",
    INSTALLSTR="Installing [$TARGET]",
)
Export("target_env")

######################################################################################################
#                                           Code Generation                                          #
######################################################################################################


def create_build_h_replacements(out_file: str):
    macro_defs = {
        "$ARCH": f"#define ARCH {arch} // Target architecture of the kernel.",
        "$SYSTEM_LOADER": target_env["system_loader"]
    }
    if "64" in arch:
        macro_defs["$BIT"] = "#define BIT64 //Activate 64-bit related features"

    if target_env["qemu_build"]:
        macro_defs["$QEMU"] = "#define QEMU_HOST // Enable Qemu related debugging features."

    if build == "test" or build == "ci":
        macro_defs["$RUN_UNIT_TESTS"] = "#define RUN_UNIT_TESTS // Execute the kernel unit tests."
    else:
        macro_defs["$RUN_UNIT_TESTS"] = ""

    if build == "ci":
        macro_defs[
            "$SHUTDOWN_ON_SYSTEM_LOADER_EXIT"] = "#define SHUTDOWN_ON_SYSTEM_LOADER_EXIT // Shutdown the system when the system loader exits unexpectedly."
    else:
        macro_defs["$SHUTDOWN_ON_SYSTEM_LOADER_EXIT"] = ""

    with open(out_file, "w") as f:
        json.dump(macro_defs, f, indent=4)


# Only run code generation if the kernel should be build
if not GetOption("clean"):
    # Provide the python scripts as source so the code gen is always triggered when the scripts are updated
    #                           OR
    # Obviously the generated source file is missing
    target_env.Command(
        f"Src/Arch/{arch}/CPU/Interrupt/ISR_Stubs.inc",
        "BuildTools/GenerateISRStubsAssembly.py",
        "python3 $SOURCE $TARGET",
    )
    target_env.Command(
        f"Src/Arch/{arch}/CPU/Interrupt/ISR_Stubs.h",
        "BuildTools/GenerateISRStubsCPP.py",
        "python3 $SOURCE $TARGET",
    )
    target_env.Command(
        "Include/KRE/System/Lat15-Terminus16.h",
        "BuildTools/PSF2ToCPP.py",
        "python3 $SOURCE $TARGET BuildTools/Lat15-Terminus16.psf",
    )
    # Dunno how to make this only run when cli args change -> just run it everytime
    create_build_h_replacements("BuildTools/BuildHReplacements.json")
    target_env.Command(
        "Include/KRE/Build.h",
        ["BuildTools/GenerateBuildHeader.py", "BuildTools/BuildHReplacements.json"],
        "python3 $SOURCE $TARGET BuildTools/BuildHReplacements.json && clang-format-19 $TARGET -i",
    )

######################################################################################################
#                                           Kernel build                                             #
######################################################################################################


build_dir = Path("Build") / f"{arch}-{build}"
target_env.SConscript(
    str(Path("Src") / "Ember" / "SConscript"),
    variant_dir=str(build_dir / "Ember"),
    duplicate=0,
)
target_env.SConscript(
    str(Path("Src") / "KRE" / "SConscript"),
    variant_dir=str(build_dir / "KRE"),
    duplicate=0,
)
target_env.SConscript(
    str(Path("Src") / "Arch" / arch / "SConscript"),
    variant_dir=str(build_dir / "Arch"),
    duplicate=0,
)
target_env.SConscript(
    str(Path("Src") / "Memory" / "SConscript"),
    variant_dir=str(build_dir / "Memory"),
    duplicate=0,
)
target_env.SConscript(
    str(Path("Src") / "CPU" / "SConscript"),
    variant_dir=str(build_dir / "CPU"),
    duplicate=0,
)
target_env.SConscript(
    str(Path("Src") / "Device" / "SConscript"),
    variant_dir=str(build_dir / "Device"),
    duplicate=0,
)
target_env.SConscript(
    str(Path("Src") / "VirtualFileSystem" / "SConscript"),
    variant_dir=str(build_dir / "VirtualFileSystem"),
    duplicate=0,
)
target_env.SConscript(
    str(Path("Src") / "App" / "SConscript"),
    variant_dir=str(build_dir / "App"),
    duplicate=0,
)
target_env.SConscript(
    str(Path("Src") / "SystemCall" / "SConscript"),
    variant_dir=str(build_dir / "SystemCall"),
    duplicate=0,
)
target_env.SConscript(
    str(Path("Src") / "BuiltInPlugin" / "SConscript"),
    variant_dir=str(build_dir / "BuiltInPlugin"),
    duplicate=0,
)
target_env.SConscript(
    str(Path("Src") / "Boot" / "SConscript"),
    variant_dir=str(build_dir / "Boot"),
    duplicate=0,
)

if build == "test" or build == "ci":
    target_env.SConscript(
        str(Path("Src") / "Test" / "SConscript"),
        variant_dir=str(build_dir / "Test" / "Heimdall"),
        duplicate=0,
    )
    Import("Heimdall")

Import("Ember")
Import("KRE")
Import("Arch")
Import("Memory")
Import("CPU")
Import("Device")
Import("VirtualFileSystem")
Import("App")
Import("SystemCall")
Import("BuiltInPlugin")
Import("Boot")
Import("crti")
Import("crtn")

if build == "test" or build == "ci":
    objects = [
        crti,
        target_env["crt_begin"],
        Boot,
        BuiltInPlugin,
        Heimdall,
        SystemCall,
        App,
        VirtualFileSystem,
        Device,
        CPU,
        Memory,
        Arch,
        KRE,
        Ember,
        target_env["crt_end"],
        crtn,
    ]
else:
    objects = [
        crti,
        target_env["crt_begin"],
        Boot,
        BuiltInPlugin,
        SystemCall,
        App,
        VirtualFileSystem,
        Device,
        CPU,
        Memory,
        Arch,
        KRE,
        Ember,
        target_env["crt_end"],
        crtn,
    ]

target_env.Append(LINKFLAGS=["-T", target_env.File("Kernel.ld").srcnode().path])

target_env.CompilationDatabase(build_dir / "compile_commands")
target_env.Program(build_dir / "runeKernel.elf", objects)
